/*
此程序为仿时钟功能，四位数码管上显示分钟和秒钟
每隔一秒数码管秒钟上会自动加一
当按下SW8时，可以对分钟还是秒钟进行选位
当在对分钟或秒钟进行选位时，短按KEY1，可以对该位加1，长按时加5
在进行调时的时候，秒钟不会再每秒加一，无操作三秒后，会复原
*/

#include <iom16v.h>
#include <macros.h>

#define CLR_SHCLK() PORTB &= ~(1<<1)//移位时钟 SCLK
#define SET_SHCLK() PORTB |= (1<<1)	//移位时钟 SCLK，上升沿

#define CLR_STCLK() PORTB &= ~(1<<0) //锁存时钟 RCLK
#define SET_STCLK() PORTB |= (1<<0)	//拉高锁存时钟，上升沿

#define CLR_DS()	PORTA &= ~(1<<0)//清零
#define SET_DS()	PORTA |= (1<<0)	//置位

#define key_input ((PIND&(1<<3))|(PINA&(1<<7)))
#define key_state_0 0
#define key_state_1 1
#define key_state_2 2
#define key_state_3 3
#define nokey 0
#define SW8 1
#define key1_short 2
#define key1_long 3

#define noflash 0
#define secflash 1
#define minflash 2


//定义字符表 		   														
unsigned char led_7[14] = {0xc0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,
		 	  			   0x80,0x90,0xff,0x7f,0xc6,0x00};
unsigned char disp_buff_min_number = 0;	
unsigned char disp_buff_sec_number = 0;				 
unsigned char disp_buff[4] = {0,0,0,0};
unsigned char post = 0;
unsigned char time_10ms_count = 0;
unsigned char time_10ms_ok = 0;
unsigned char time_300ms_count = 0;
unsigned char time_300ms_ok = 0;
unsigned int time_1s_count = 0;
unsigned char time_1s_ok = 0;
unsigned char isflash = noflash;
unsigned char flash_count = 0;

unsigned char read_key(void)
{
	static unsigned char key_state = 0,key_time;
	unsigned char key_press,key_return = nokey;

	key_press = key_input;//读取按键电平
	switch(key_state)
	{
		case key_state_0:
			if(key_press != 0x88)	//按键按下，转确认状态
				key_state = key_state_1;
			break;
		case key_state_1:
			if(key_press != 0x88)
			{
				if(key_press == 0x80)	//SW8按键按下，因为无长按，所以直接转状态3判定是否松开
				{
					key_state = key_state_3;
					key_return = SW8;
				}
				if(key_press == 0x08)	//key1按下，转状态2判定为长按还是短按
				{	
					key_state = key_state_2;
					key_time = 0;
				}
			}
			else				//按键无按下（抖动）
				key_state = key_state_0;
			break;
		case key_state_2:
			if(key_press == 0x88)	//按下时间不过1S，为短按
			{	
				key_state = key_state_0;
				key_time = 0;
				key_return = key1_short;
			}
			else if((++key_time) >= 100)	//按下时间超过1S，为长按
			{
				key_state = key_state_3;
				key_time = 0;
				key_return = key1_long;
			}
			break;
		case key_state_3:
			if(key_press == 0x88)	//无按键按下了
				key_state = 0;
			else if(((++key_time) >= 50)  && (key_press == 0x08))	//key1长按后每隔0.5S为下一次长按
			{
				key_time = 0;
				key_return = key1_long;
			}
			break;
	}
	return key_return;
}

void HC595_send_byte(unsigned char SndData)
{
    //完成595的驱动函数，实现通过595把串行数据发送到Q0——Q7
	unsigned char i;
	for(i=0;i<8;i++)
	{
	 	if((SndData&(1<<(7-i)))==0)
			CLR_DS();
		else
			SET_DS();
		CLR_SHCLK();
		SET_SHCLK();
	}
	CLR_STCLK();
	SET_STCLK();
}

void port_init(void)
{
 //添加使用到的管脚初始化
 	DDRA|=(1<<0);
	DDRA&=~(1<<7);
	PORTA|=(1<<7);
	DDRB|=(1<<0)|(1<<1);
	PORTB|=(1<<1);
	DDRD|=0xf0;
	PORTD&=0X0F;
	DDRD&=~(1<<3);
	PORTD|=(1<<3);
}

void timer0_init(void)
{
	TCCR0 = 0x00; //stop
	TCNT0 = 0x1A; //set count
	OCR0  = 0xE6;  //set compare
	TCCR0 = 0x03; //start timer
}

#pragma interrupt_handler timer0_ovf_isr:iv_TIM0_OVF
void timer0_ovf_isr(void)
{
	TCNT0 = 0x1A; //reload counter value
	PORTD|=0xf0;
	//正常计数时，正常送数，点亮对应的数码管
	//进行调时时，正常送数，每隔0.3秒点亮对应数码管，实现闪烁功能
	if(post == 1)
		HC595_send_byte(led_7[disp_buff[post]] & ~(1<<7));
	else
		HC595_send_byte(led_7[disp_buff[post]]);
	if(isflash == secflash && time_300ms_ok && (post == 2 || post == 3))
		PORTD |= 0XF0;
	else if(isflash == minflash && time_300ms_ok && (post == 0 || post == 1))
		PORTD |= 0XF0;
	else
		PORTD&=~(1<<(7-post));
	if(++post>=4)
		post=0;
	if(++time_10ms_count >= 5)
	{
		time_10ms_ok = 1;
		time_10ms_count = 0;
	}
	if(++time_300ms_count >= 150)
	{
		time_300ms_ok = ~time_300ms_ok;
		time_300ms_count = 0;
	}
	if(++time_1s_count >= 500)
	{
		time_1s_ok = 1;
		time_1s_count = 0;
	}
}

//call this routine to initialize all peripherals
void init_devices(void)
{
 //stop errant interrupts until set up
 CLI(); //disable all interrupts
 port_init();
 timer0_init();

 MCUCR = 0x00;
 GICR  = 0x00;
 TIMSK = 0x01; //timer interrupt sources
 SEI(); //re-enable interrupts
 //all peripherals are now initialized
}

void main(void)
{
	init_devices();
	while(1)
	{
		if(time_1s_ok)
		{
			flash_count++;
			if(flash_count >= 3)
			{
				isflash = noflash;
				flash_count = 0;
			}
			time_1s_ok = 0;
			if(isflash == noflash)
			{
				if(++disp_buff_sec_number >= 60)
				{
					disp_buff_sec_number = 0;
					if(++disp_buff_min_number >= 60)
					{
						disp_buff_min_number = 0;
					}
				}
				disp_buff[0] = disp_buff_min_number/10;
				disp_buff[1] = disp_buff_min_number%10;
				disp_buff[2] = disp_buff_sec_number/10;
				disp_buff[3] = disp_buff_sec_number%10;
			}
		}
		if(time_10ms_ok)
		{
			time_10ms_ok = 0;
			switch(read_key())
			{
				case SW8:
					flash_count = 0;
					if(isflash == noflash)
						isflash = secflash;
					else if(isflash == secflash)
						isflash = minflash;
					else 
						isflash = secflash;
					break;
				case key1_short:
					flash_count = 0;
					if(isflash == secflash)
					{
						if(++disp_buff_sec_number >= 60)
							disp_buff_sec_number = 0;
					}
					else if(isflash == minflash)
					{
						if(++disp_buff_min_number >= 60)
							disp_buff_min_number = 0;
					}
					disp_buff[0] = disp_buff_min_number/10;
					disp_buff[1] = disp_buff_min_number%10;
					disp_buff[2] = disp_buff_sec_number/10;
					disp_buff[3] = disp_buff_sec_number%10;
					break;
				case key1_long:
					flash_count = 0;
					if(isflash == secflash)
					{
						disp_buff_sec_number = disp_buff_sec_number + 5;
						if(disp_buff_sec_number >= 60)
							disp_buff_sec_number = disp_buff_sec_number % 60;
					}
					else if(isflash == minflash)
					{
						disp_buff_min_number = disp_buff_min_number + 5;
						if(disp_buff_min_number >= 60)
							disp_buff_min_number = disp_buff_min_number % 60;
					}
					disp_buff[0] = disp_buff_min_number/10;
					disp_buff[1] = disp_buff_min_number%10;
					disp_buff[2] = disp_buff_sec_number/10;
					disp_buff[3] = disp_buff_sec_number%10;
					break;
			}
		}
	}
}